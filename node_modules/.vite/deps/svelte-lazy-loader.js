import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  append_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  bubble,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  get_all_dirty_from_scope,
  get_slot_changes,
  init,
  insert_dev,
  listen_dev,
  noop,
  null_to_empty,
  onMount,
  safe_not_equal,
  space,
  src_url_equal,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-CKECMU6L.js";
import "./chunk-HYZYPRER.js";

// node_modules/svelte-lazy-loader/components/Image.svelte
var file = "node_modules/svelte-lazy-loader/components/Image.svelte";
function add_css(target) {
  append_styles(target, "svelte-12jqvvh", "img.svelte-12jqvvh{transition:var(--transition, filter cubic-bezier(0.4, 0, 0.2, 1) 300ms)}img[data-loaded='false'].svelte-12jqvvh{-webkit-filter:var(--filter, blur(10px));filter:var(--filter, blur(10px))}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2Uuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXFHQyxrQkFBSSxDQUNILFVBQVUsQ0FBRSxJQUFJLFlBQVksQ0FBQywwQ0FBMEMsQ0FDeEUsQ0FDQSxHQUFHLENBQUMsV0FBVyxDQUFDLE9BQU8sZ0JBQUUsQ0FDeEIsY0FBYyxDQUFFLElBQUksUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUN6QyxNQUFNLENBQUUsSUFBSSxRQUFRLENBQUMsV0FBVyxDQUNqQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJJbWFnZS5zdmVsdGUiXX0= */");
}
function create_fragment(ctx) {
  let img;
  let img_class_value;
  let img_src_value;
  let img_srcset_value;
  let img_data_srcset_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      img = element("img");
      attr_dev(img, "class", img_class_value = /*classes*/
      ctx[9] + " svelte-lazy-loader svelte-12jqvvh");
      if (!src_url_equal(img.src, img_src_value = /*loading*/
      ctx[1] === "lazy" ? (
        /*placeholder*/
        ctx[3]
      ) : (
        /*src*/
        ctx[4]
      )))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "srcset", img_srcset_value = /*loading*/
      ctx[1] === "lazy" ? (
        /*placeholder*/
        ctx[3]
      ) : (
        /*srcset*/
        ctx[5]
      ));
      attr_dev(
        img,
        "sizes",
        /*sizes*/
        ctx[6]
      );
      attr_dev(
        img,
        "alt",
        /*alt*/
        ctx[2]
      );
      attr_dev(
        img,
        "height",
        /*height*/
        ctx[11]
      );
      attr_dev(
        img,
        "width",
        /*width*/
        ctx[10]
      );
      attr_dev(
        img,
        "loading",
        /*loading*/
        ctx[1]
      );
      attr_dev(
        img,
        "decoding",
        /*decoding*/
        ctx[8]
      );
      attr_dev(
        img,
        "draggable",
        /*draggable*/
        ctx[7]
      );
      attr_dev(
        img,
        "data-src",
        /*src*/
        ctx[4]
      );
      attr_dev(img, "data-srcset", img_data_srcset_value = /*srcset*/
      ctx[5] || /*src*/
      ctx[4]);
      attr_dev(img, "data-loaded", "false");
      add_location(img, file, 82, 0, 3155);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
      ctx[13](img);
      if (!mounted) {
        dispose = listen_dev(
          img,
          "load",
          /*load_handler*/
          ctx[12],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*classes*/
      512 && img_class_value !== (img_class_value = /*classes*/
      ctx2[9] + " svelte-lazy-loader svelte-12jqvvh")) {
        attr_dev(img, "class", img_class_value);
      }
      if (dirty & /*loading, placeholder, src*/
      26 && !src_url_equal(img.src, img_src_value = /*loading*/
      ctx2[1] === "lazy" ? (
        /*placeholder*/
        ctx2[3]
      ) : (
        /*src*/
        ctx2[4]
      ))) {
        attr_dev(img, "src", img_src_value);
      }
      if (dirty & /*loading, placeholder, srcset*/
      42 && img_srcset_value !== (img_srcset_value = /*loading*/
      ctx2[1] === "lazy" ? (
        /*placeholder*/
        ctx2[3]
      ) : (
        /*srcset*/
        ctx2[5]
      ))) {
        attr_dev(img, "srcset", img_srcset_value);
      }
      if (dirty & /*sizes*/
      64) {
        attr_dev(
          img,
          "sizes",
          /*sizes*/
          ctx2[6]
        );
      }
      if (dirty & /*alt*/
      4) {
        attr_dev(
          img,
          "alt",
          /*alt*/
          ctx2[2]
        );
      }
      if (dirty & /*height*/
      2048) {
        attr_dev(
          img,
          "height",
          /*height*/
          ctx2[11]
        );
      }
      if (dirty & /*width*/
      1024) {
        attr_dev(
          img,
          "width",
          /*width*/
          ctx2[10]
        );
      }
      if (dirty & /*loading*/
      2) {
        attr_dev(
          img,
          "loading",
          /*loading*/
          ctx2[1]
        );
      }
      if (dirty & /*decoding*/
      256) {
        attr_dev(
          img,
          "decoding",
          /*decoding*/
          ctx2[8]
        );
      }
      if (dirty & /*draggable*/
      128) {
        attr_dev(
          img,
          "draggable",
          /*draggable*/
          ctx2[7]
        );
      }
      if (dirty & /*src*/
      16) {
        attr_dev(
          img,
          "data-src",
          /*src*/
          ctx2[4]
        );
      }
      if (dirty & /*srcset, src*/
      48 && img_data_srcset_value !== (img_data_srcset_value = /*srcset*/
      ctx2[5] || /*src*/
      ctx2[4])) {
        attr_dev(img, "data-srcset", img_data_srcset_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
      ctx[13](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var loadingExists;
var observer;
var loadAttributes = (el) => {
  el.src = el.dataset.src;
  el.srcset = el.dataset.srcset;
  el.dataset.loaded = true;
};
if (typeof window !== "undefined") {
  loadingExists = "loading" in HTMLImageElement.prototype;
  if (!loadingExists) {
    observer = new IntersectionObserver(
      (entries, observer3) => {
        entries.forEach(({ isIntersecting, target }) => {
          if (isIntersecting) {
            loadAttributes(target);
            observer3.unobserve(target);
          }
        });
      },
      { rootMargin: "200px 200px" }
    );
  }
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, []);
  let { loading = "lazy" } = $$props;
  let { alt = "" } = $$props;
  let { placeholder = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8+fOvJAAI7AMKHxaZiQAAAABJRU5ErkJggg==" } = $$props;
  let { src = placeholder } = $$props;
  let { srcset = src } = $$props;
  let { sizes = "" } = $$props;
  let { draggable = true } = $$props;
  let { decoding = "async" } = $$props;
  let { classes = "" } = $$props;
  let { width = "100%" } = $$props;
  let { height = "100%" } = $$props;
  let { el = void 0 } = $$props;
  onMount(() => {
    if (loadingExists)
      loadAttributes(el);
    else if (observer && loading === "lazy")
      observer.observe(el);
  });
  const writable_props = [
    "loading",
    "alt",
    "placeholder",
    "src",
    "srcset",
    "sizes",
    "draggable",
    "decoding",
    "classes",
    "width",
    "height",
    "el"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Image> was created with unknown prop '${key}'`);
  });
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function img_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("loading" in $$props2)
      $$invalidate(1, loading = $$props2.loading);
    if ("alt" in $$props2)
      $$invalidate(2, alt = $$props2.alt);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("src" in $$props2)
      $$invalidate(4, src = $$props2.src);
    if ("srcset" in $$props2)
      $$invalidate(5, srcset = $$props2.srcset);
    if ("sizes" in $$props2)
      $$invalidate(6, sizes = $$props2.sizes);
    if ("draggable" in $$props2)
      $$invalidate(7, draggable = $$props2.draggable);
    if ("decoding" in $$props2)
      $$invalidate(8, decoding = $$props2.decoding);
    if ("classes" in $$props2)
      $$invalidate(9, classes = $$props2.classes);
    if ("width" in $$props2)
      $$invalidate(10, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(11, height = $$props2.height);
    if ("el" in $$props2)
      $$invalidate(0, el = $$props2.el);
  };
  $$self.$capture_state = () => ({
    loadingExists,
    observer,
    loadAttributes,
    onMount,
    loading,
    alt,
    placeholder,
    src,
    srcset,
    sizes,
    draggable,
    decoding,
    classes,
    width,
    height,
    el
  });
  $$self.$inject_state = ($$props2) => {
    if ("loading" in $$props2)
      $$invalidate(1, loading = $$props2.loading);
    if ("alt" in $$props2)
      $$invalidate(2, alt = $$props2.alt);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("src" in $$props2)
      $$invalidate(4, src = $$props2.src);
    if ("srcset" in $$props2)
      $$invalidate(5, srcset = $$props2.srcset);
    if ("sizes" in $$props2)
      $$invalidate(6, sizes = $$props2.sizes);
    if ("draggable" in $$props2)
      $$invalidate(7, draggable = $$props2.draggable);
    if ("decoding" in $$props2)
      $$invalidate(8, decoding = $$props2.decoding);
    if ("classes" in $$props2)
      $$invalidate(9, classes = $$props2.classes);
    if ("width" in $$props2)
      $$invalidate(10, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(11, height = $$props2.height);
    if ("el" in $$props2)
      $$invalidate(0, el = $$props2.el);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    el,
    loading,
    alt,
    placeholder,
    src,
    srcset,
    sizes,
    draggable,
    decoding,
    classes,
    width,
    height,
    load_handler,
    img_binding
  ];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        loading: 1,
        alt: 2,
        placeholder: 3,
        src: 4,
        srcset: 5,
        sizes: 6,
        draggable: 7,
        decoding: 8,
        classes: 9,
        width: 10,
        height: 11,
        el: 0
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment.name
    });
  }
  get loading() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get srcset() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set srcset(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sizes() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sizes(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get draggable() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set draggable(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decoding() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decoding(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classes() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classes(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get el() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set el(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Image_default = Image;

// node_modules/svelte-lazy-loader/components/Picture.svelte
var file2 = "node_modules/svelte-lazy-loader/components/Picture.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1quqpl1", "picture.svelte-1quqpl1{transition:var(--transition, filter cubic-bezier(0.4, 0, 0.2, 1) 300ms)}picture[data-loaded='false'].svelte-1quqpl1{-webkit-filter:var(--filter, blur(10px));filter:var(--filter, blur(10px))}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGljdHVyZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBbUdDLHNCQUFRLENBQ1AsVUFBVSxDQUFFLElBQUksWUFBWSxDQUFDLDBDQUEwQyxDQUN4RSxDQUNBLE9BQU8sQ0FBQyxXQUFXLENBQUMsT0FBTyxnQkFBRSxDQUM1QixjQUFjLENBQUUsSUFBSSxRQUFRLENBQUMsV0FBVyxDQUFDLENBQ3pDLE1BQU0sQ0FBRSxJQUFJLFFBQVEsQ0FBQyxXQUFXLENBQ2pDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlBpY3R1cmUuc3ZlbHRlIl19 */");
}
function create_fragment2(ctx) {
  let picture;
  let t;
  let img;
  let img_src_value;
  let picture_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const block = {
    c: function create() {
      picture = element("picture");
      if (default_slot)
        default_slot.c();
      t = space();
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*loading*/
      ctx[1] === "lazy" ? (
        /*placeholder*/
        ctx[3]
      ) : (
        /*src*/
        ctx[4]
      )))
        attr_dev(img, "src", img_src_value);
      attr_dev(
        img,
        "alt",
        /*alt*/
        ctx[2]
      );
      attr_dev(
        img,
        "height",
        /*height*/
        ctx[9]
      );
      attr_dev(
        img,
        "width",
        /*width*/
        ctx[8]
      );
      attr_dev(
        img,
        "loading",
        /*loading*/
        ctx[1]
      );
      attr_dev(
        img,
        "decoding",
        /*decoding*/
        ctx[6]
      );
      attr_dev(
        img,
        "draggable",
        /*draggable*/
        ctx[5]
      );
      attr_dev(
        img,
        "data-src",
        /*src*/
        ctx[4]
      );
      add_location(img, file2, 85, 1, 3098);
      attr_dev(picture, "class", picture_class_value = null_to_empty(
        /*classes*/
        ctx[7]
      ) + " svelte-1quqpl1");
      attr_dev(picture, "data-loaded", "false");
      add_location(picture, file2, 83, 0, 3026);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, picture, anchor);
      if (default_slot) {
        default_slot.m(picture, null);
      }
      append_dev(picture, t);
      append_dev(picture, img);
      ctx[13](picture);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          img,
          "load",
          /*load_handler*/
          ctx[12],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*loading, placeholder, src*/
      26 && !src_url_equal(img.src, img_src_value = /*loading*/
      ctx2[1] === "lazy" ? (
        /*placeholder*/
        ctx2[3]
      ) : (
        /*src*/
        ctx2[4]
      ))) {
        attr_dev(img, "src", img_src_value);
      }
      if (!current || dirty & /*alt*/
      4) {
        attr_dev(
          img,
          "alt",
          /*alt*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*height*/
      512) {
        attr_dev(
          img,
          "height",
          /*height*/
          ctx2[9]
        );
      }
      if (!current || dirty & /*width*/
      256) {
        attr_dev(
          img,
          "width",
          /*width*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*loading*/
      2) {
        attr_dev(
          img,
          "loading",
          /*loading*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*decoding*/
      64) {
        attr_dev(
          img,
          "decoding",
          /*decoding*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*draggable*/
      32) {
        attr_dev(
          img,
          "draggable",
          /*draggable*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*src*/
      16) {
        attr_dev(
          img,
          "data-src",
          /*src*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*classes*/
      128 && picture_class_value !== (picture_class_value = null_to_empty(
        /*classes*/
        ctx2[7]
      ) + " svelte-1quqpl1")) {
        attr_dev(picture, "class", picture_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(picture);
      if (default_slot)
        default_slot.d(detaching);
      ctx[13](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var loadingExists2;
var observer2;
var loadAttributes2 = (el) => {
  const imgEl = el.querySelector("img");
  imgEl.src = imgEl.dataset.src;
  const sourceEls = el.querySelectorAll("source");
  sourceEls.forEach((sourceEl) => sourceEl.srcset = sourceEl.dataset.srcset);
  el.dataset.loaded = true;
};
if (typeof window !== "undefined") {
  loadingExists2 = "loading" in HTMLImageElement.prototype;
  if (!loadingExists2) {
    observer2 = new IntersectionObserver(
      (entries, observer3) => {
        entries.forEach(({ isIntersecting, target }) => {
          if (isIntersecting) {
            loadAttributes2(target);
            observer3.unobserve(target);
          }
        });
      },
      { rootMargin: "200px 200px" }
    );
  }
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Picture", slots, ["default"]);
  let { loading = "lazy" } = $$props;
  let { alt = "" } = $$props;
  let { placeholder = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8+fOvJAAI7AMKHxaZiQAAAABJRU5ErkJggg==" } = $$props;
  let { src = placeholder } = $$props;
  let { draggable = true } = $$props;
  let { decoding = "async" } = $$props;
  let { classes = "" } = $$props;
  let { width = "100%" } = $$props;
  let { height = "100%" } = $$props;
  let { el = void 0 } = $$props;
  onMount(() => {
    if (loadingExists2)
      loadAttributes2(el);
    else if (observer2 && loading === "lazy")
      observer2.observe(el);
  });
  const writable_props = [
    "loading",
    "alt",
    "placeholder",
    "src",
    "draggable",
    "decoding",
    "classes",
    "width",
    "height",
    "el"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Picture> was created with unknown prop '${key}'`);
  });
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function picture_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("loading" in $$props2)
      $$invalidate(1, loading = $$props2.loading);
    if ("alt" in $$props2)
      $$invalidate(2, alt = $$props2.alt);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("src" in $$props2)
      $$invalidate(4, src = $$props2.src);
    if ("draggable" in $$props2)
      $$invalidate(5, draggable = $$props2.draggable);
    if ("decoding" in $$props2)
      $$invalidate(6, decoding = $$props2.decoding);
    if ("classes" in $$props2)
      $$invalidate(7, classes = $$props2.classes);
    if ("width" in $$props2)
      $$invalidate(8, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(9, height = $$props2.height);
    if ("el" in $$props2)
      $$invalidate(0, el = $$props2.el);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    loadingExists: loadingExists2,
    observer: observer2,
    loadAttributes: loadAttributes2,
    onMount,
    loading,
    alt,
    placeholder,
    src,
    draggable,
    decoding,
    classes,
    width,
    height,
    el
  });
  $$self.$inject_state = ($$props2) => {
    if ("loading" in $$props2)
      $$invalidate(1, loading = $$props2.loading);
    if ("alt" in $$props2)
      $$invalidate(2, alt = $$props2.alt);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("src" in $$props2)
      $$invalidate(4, src = $$props2.src);
    if ("draggable" in $$props2)
      $$invalidate(5, draggable = $$props2.draggable);
    if ("decoding" in $$props2)
      $$invalidate(6, decoding = $$props2.decoding);
    if ("classes" in $$props2)
      $$invalidate(7, classes = $$props2.classes);
    if ("width" in $$props2)
      $$invalidate(8, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(9, height = $$props2.height);
    if ("el" in $$props2)
      $$invalidate(0, el = $$props2.el);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    el,
    loading,
    alt,
    placeholder,
    src,
    draggable,
    decoding,
    classes,
    width,
    height,
    $$scope,
    slots,
    load_handler,
    picture_binding
  ];
}
var Picture = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        loading: 1,
        alt: 2,
        placeholder: 3,
        src: 4,
        draggable: 5,
        decoding: 6,
        classes: 7,
        width: 8,
        height: 9,
        el: 0
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Picture",
      options,
      id: create_fragment2.name
    });
  }
  get loading() {
    throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get draggable() {
    throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set draggable(value) {
    throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decoding() {
    throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decoding(value) {
    throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classes() {
    throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classes(value) {
    throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get el() {
    throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set el(value) {
    throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Picture_default = Picture;
export {
  Image_default as Image,
  Picture_default as Picture
};
//# sourceMappingURL=svelte-lazy-loader.js.map
